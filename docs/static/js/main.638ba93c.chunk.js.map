{"version":3,"sources":["Components/Controls.js","Components/AnimatedSpheres.js","Components/Sphere.js","Components/Plane.js","Components/Scene.jsx","Components/About.jsx","Components/Projects.jsx","App.js","index.js"],"names":["extend","OrbitControls","spheres","i","Math","floor","color","THREE","random","push","position","key","start","AnimatedSphere","animated","zPositionOffset","shouldRise","index","menuFunction","useState","rise","setRise","tempVector","useSpringRef","props","useSpring","yposition","config","duration","sphereRef","useRef","useFrame","current","z","getWorldPosition","console","log","useEffect","mesh","ref","attach","meshPhysicalMaterial","AnimatedSpheres","menuFunctions","riseValues","React","useContext","SphereContext","map","sphere","length","values","Plane","useThree","scene","gl","rotation","PI","receiveShadow","Reflector","args","resolution","mirror","mixBlur","mixStrength","depthScale","minDepthThreshold","maxDepthThreshold","depthToBlurRatioBias","distortion","debug","Material","Scene","group","About","menuFunc","className","onPointerEnter","onPointerLeave","Projects","createContext","App","activePage","setActivePage","style","width","height","camera","onCreated","shadowMap","enabled","type","Provider","value","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.638ba93c.chunk.js","sourcesContent":["import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'\r\nimport { extend, useFrame, useThree } from '@react-three/fiber'\r\nimport { useRef } from 'react'\r\n\r\nextend({ OrbitControls })\r\n\r\nexport const Controls = () => {\r\n  const orbitRef = useRef();\r\n  const { camera, gl } = useThree();\r\n  useFrame((delta, state) => {\r\n    orbitRef.current.update();\r\n  })\r\n  return (\r\n    <orbitControls\r\n      maxPolarAngle={Math.PI}\r\n      minPolarAngle={Math.PI / 5}\r\n      ref={orbitRef}\r\n      args={[camera, gl.domElement]}\r\n    />\r\n  )\r\n}","import { extend, useFrame } from '@react-three/fiber'\r\nimport { useSpring, animated } from '@react-spring/three'\r\nimport { Sphere } from './Sphere.js'\r\nimport React from 'react'\r\nimport * as THREE from 'three'\r\nimport {SphereContext} from '../App'\r\n\r\nconst spheres = []\r\nconst numSpheres = 5\r\nfor (let i = 0; i < Math.floor(numSpheres); i++) {\r\n    let color = new THREE.Color(Math.random(), Math.random(), Math.random());\r\n    spheres.push({ color: color, position: [-1.5, 0.5, i * 4], key: i, start: false })\r\n}\r\nconst AnimatedSphere = animated(Sphere)\r\nexport const AnimatedSpheres = ({ menuFunctions }) => {\r\n    const riseValues = React.useContext(SphereContext);\r\n    console.log(riseValues);\r\n    return (menuFunctions?<>\r\n        {spheres.map((sphere, index) => {\r\n            return index < menuFunctions.length? <AnimatedSphere color={sphere.color} key={sphere.key} position={sphere.position} index={index} menuFunction={menuFunctions[index]} shouldRise={riseValues.values[index]}></AnimatedSphere> : null\r\n        })}\r\n    </> : null)\r\n}","import { useSpring, useSpringRef, a, } from '@react-spring/three'\r\nimport * as THREE from 'three'\r\nimport { useRef, useState, useEffect } from 'react'\r\nimport { useFrame } from '@react-three/fiber';\r\n\r\n\r\nexport const Sphere = ({ start, position, color, index, menuFunction, shouldRise }) => {\r\n    let zPositionOffset\r\n    const [rise, setRise] = useState()\r\n    const springRef = useSpringRef()\r\n    let tempVector = new THREE.Vector3();\r\n    const props = useSpring(\r\n        { yposition: rise ? 1.5 : position[1], color: color, config: { duration: 200 } }\r\n    )\r\n\r\n    const sphereRef = useRef();\r\n    useFrame(() => {\r\n        if (typeof zPositionOffset != \"number\") {\r\n            zPositionOffset = 0\r\n        }\r\n        //zPositionOffset += 0.05\r\n        sphereRef.current.position.z = position[2] + zPositionOffset\r\n        sphereRef.current.getWorldPosition(tempVector);\r\n        if (tempVector.z > 20) {\r\n            console.log('resettings')\r\n            zPositionOffset = -position[2] - 20;\r\n        }\r\n    })\r\n\r\n    useEffect(() => {\r\n        setRise(shouldRise)\r\n    }, [shouldRise])\r\n\r\n    return (\r\n        <a.mesh\r\n            ref={sphereRef}\r\n            position-x={position[0]}\r\n            position-y={props.yposition}\r\n            //onPointerEnter={()=> {setRise(true)}}\r\n            //onPointerOut={() => {setRise(false)}}\r\n            //onPointerDown={() => {menuFunction()}}\r\n            >\r\n            <sphereBufferGeometry attach=\"geometry\"></sphereBufferGeometry>\r\n            <a.meshPhysicalMaterial attach=\"material\" color={props.color}></a.meshPhysicalMaterial>\r\n        </a.mesh>\r\n    )\r\n}","import { useEffect } from 'react'\r\nimport * as THREE from 'three'\r\nimport { useThree, useFrame } from '@react-three/fiber'\r\nimport { Reflector } from '@react-three/drei'\r\n\r\n\r\nlet cubeGeom, mirrorCubeCamera, mirrorCubeMaterial, mirrorCube, cubeRenderTarget\r\nexport const Plane = () => {\r\n  const { scene, gl } = useThree()\r\n  /*\r\n  useEffect(() => {\r\n    cubeRenderTarget = new THREE.WebGLCubeRenderTarget(1024, { format: THREE.RGBFormat, generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter })\r\n    cubeGeom = new THREE.BoxGeometry(10, 0.1, 60);\r\n    mirrorCubeCamera = new THREE.CubeCamera(0.1, 5000, cubeRenderTarget);\r\n    // mirrorCubeCamera.renderTarget.minFilter = THREE.LinearMipMapLinearFilter;\r\n    scene.add(mirrorCubeCamera);\r\n    mirrorCubeMaterial = new THREE.MeshBasicMaterial({ envMap: cubeRenderTarget.texture });\r\n    mirrorCube = new THREE.Mesh(cubeGeom, mirrorCubeMaterial);\r\n    mirrorCube.position.set(0, -4, 0);\r\n    mirrorCubeCamera.position.set(mirrorCube.position.x, mirrorCube.position.y, mirrorCube.position.z);\r\n    scene.add(mirrorCube);\r\n  }, [])\r\n\r\n  useFrame(() => {\r\n    if (mirrorCube) {\r\n      console.log('updating cube')\r\n      mirrorCube.visible = false;\r\n      mirrorCubeCamera.updateCubeMap(gl, scene)\r\n      mirrorCube.visible = true;\r\n    }\r\n  })*/\r\n  return (\r\n    <mesh\r\n      rotation={[-Math.PI / 2, 0, 0]}\r\n      position={[0, -0.5, 0]}\r\n      receiveShadow>\r\n      <Reflector\r\n        args={[256, 256]} // PlaneBufferGeometry arguments\r\n        resolution={2048} // Off-buffer resolution, lower=faster, higher=better quality\r\n        mirror={1} // Mirror environment, 0 = texture colors, 1 = pick up env colors\r\n        mixBlur={0.75} // How much blur mixes with surface roughness (default = 0), note that this can affect performance\r\n        mixStrength={0.5} // Strength of the reflections\r\n        depthScale={0.5} // Scale the depth factor (0 = no depth, default = 0)\r\n        minDepthThreshold={0.9} // Lower edge for the depthTexture interpolation (default = 0)\r\n        maxDepthThreshold={1} // Upper edge for the depthTexture interpolation (default = 0)\r\n        depthToBlurRatioBias={0.25} // Adds a bias factor to the depthTexture before calculating the blur amount [blurFactor = blurTexture * (depthTexture + bias)]. It accepts values between 0 and 1, default is 0.25. An amount > 0 of bias makes sure that the blurTexture is not too sharp because of the multiplication with the depthTexture\r\n        distortion={0.5} // Amount of distortion based on the distortionMap texture\r\n        debug={2} /* Depending on the assigned value, one of the following channels is shown:\r\n    0 = no debug\r\n    1 = depth channel\r\n    2 = base channel\r\n    3 = distortion channel\r\n    4 = lod channel (based on the roughness)\r\n  */\r\n      >\r\n        {(Material, props) => <Material {...props} />}\r\n      </Reflector>\r\n    </mesh>\r\n  )\r\n}\r\n\r\n","import { useFrame, useThree } from '@react-three/fiber'\r\nimport { useRef } from 'react'\r\nimport * as THREE from 'three'\r\n\r\nimport { AnimatedSpheres } from './AnimatedSpheres'\r\nimport { Plane } from './Plane'\r\n\r\nfunction Scene( {menuFunctions}) {\r\n    const group = useRef();\r\n   /* const rotationEuler = new THREE.Euler(0, 0, 0);\r\n    const rotationQuaternion = new THREE.Quaternion(0, 0, 0, 0);\r\n    const { viewport } = useThree();\r\n\r\n    useFrame(({ mouse }) => {\r\n        const x = (mouse.x * viewport.width) / 100;\r\n        const y = (mouse.y * viewport.height) / 100;\r\n\r\n        rotationEuler.set(y, x, 0);\r\n        rotationQuaternion.setFromEuler(rotationEuler);\r\n\r\n        group.current.quaternion.slerp(rotationQuaternion, 0.1);\r\n    });*/\r\n    return <group ref={group}>\r\n        <AnimatedSpheres menuFunctions={menuFunctions} />\r\n        <Plane />\r\n    </group>\r\n}\r\n\r\nexport default Scene;","import \"./about.css\"\r\n\r\nfunction About({menuFunc}){\r\n    return (<>\r\n    <div className={\"aboutTab\"} onPointerEnter={menuFunc} onPointerLeave={menuFunc}><h1>About</h1></div>\r\n    </>)\r\n}\r\n\r\nexport default About","import \"./projects.css\"\r\n\r\nfunction Projects({menuFunc}){\r\n    return (<>\r\n    <div className={\"projectsTab\"} onPointerEnter={menuFunc} onPointerLeave={menuFunc}><h1>Projects</h1></div>\r\n    </>)\r\n}\r\n\r\nexport default Projects","import { Canvas, useThree, useFrame } from '@react-three/fiber'\r\nimport React, { useState, useRef } from 'react'\r\nimport * as THREE from \"three\"\r\nimport { Controls } from './Components/Controls.js'\r\nimport Scene from './Components/Scene.jsx'\r\nimport About from './Components/About.jsx'\r\nimport Projects from './Components/Projects.jsx'\r\nimport \"./styles.css\"\r\n\r\nconst SphereContext = React.createContext({ values: null })\r\n\r\nfunction App() {\r\n    const [activePage, setActivePage] = useState([0, 0,])\r\n    const menuFunctions = [function () {\r\n        setActivePage([!activePage[0], activePage[1], activePage[2]])\r\n    }, function () {\r\n        setActivePage([activePage[0], !activePage[1], activePage[2]])\r\n    }]\r\n    \r\n    return (<div style={{ width: \"100%\", height: \"100%\" }}>\r\n        <Canvas camera={{ position: [5, 5, -2] }}\r\n            onCreated={\r\n                ({ gl }) => {\r\n                    gl.shadowMap.enabled = true\r\n                    gl.shadowMap.type = THREE.PCFSoftShadowMap\r\n                }}>\r\n            <SphereContext.Provider value={{values: activePage}}>\r\n                <Scene menuFunctions={menuFunctions} />\r\n            </SphereContext.Provider>\r\n            <ambientLight />\r\n            <directionalLight></directionalLight>\r\n        </Canvas>\r\n        <div className={\"navbar\"}>\r\n            <Projects menuFunc={menuFunctions[1]}></Projects>\r\n            \r\n            <About menuFunc={menuFunctions[0]}></About>\r\n        </div>\r\n    </div>\r\n    );\r\n}\r\n\r\nexport {App, SphereContext};","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport {App} from './App';\r\n\r\nReactDOM.render(\r\n    <App />,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}